<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2025-03-16 Sun 20:29 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>git-学习笔记</title>
<meta name="author" content="pengshao" />
<meta name="keywords" content="git-learn" />
<meta name="generator" content="Org Mode" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../css/org.css" />
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_page_pv">所有文章阅读量<span id="busuanzi_value_page_pv"></span>次</span>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">git-学习笔记</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8dbfbbf">1. git set proxy</a></li>
<li><a href="#org841007a">2. git设置信息: git config</a></li>
<li><a href="#org5bfbb18">3. 建立repository: git init</a></li>
<li><a href="#org5455ba6">4. git添加文件: git add <b>*</b>.***/git commit</a></li>
<li><a href="#org3a044f4">5. repository status: git status</a></li>
<li><a href="#org93fceea">6. 查看文件不同: git diff <b>*</b>.***/git</a></li>
<li><a href="#org9e0f569">7. 版本的回退: git reset &#x2013;hard HEAD^</a>
<ul>
<li><a href="#orgc4fc2db">7.1. 在Git中，用HEAD表示当前版本</a></li>
<li><a href="#org5a9406f">7.2. 也可以红SHA1计算出来的那个大的数字&#x2013;版本号来代替HEAD^</a></li>
<li><a href="#org9e38ee0">7.3. 如果关掉电脑找不到版本号了可以通过: git reflog来找到全部的版本号码</a></li>
</ul>
</li>
<li><a href="#org892a301">8. 操作日志: git log/git reflog</a></li>
<li><a href="#org34bef56">9. working dirctory + Repository+stage概念</a></li>
<li><a href="#org89f6eab">10. 撤销修改: git checkout &#x2013; ./my-first-git.org</a></li>
<li><a href="#orgabcad22">11. 删除文件: git rm <b>*</b>.***</a>
<ul>
<li><a href="#org519b709">11.1. 用rm或者git rm删掉的文件也是一个针对版本库的修改项目</a></li>
<li><a href="#org0ad6fa3">11.2. 删错了恢复: git checkout &#x2013; ./***.***</a></li>
</ul>
</li>
<li><a href="#org0050751">12. 远程仓库: github 使用教程</a>
<ul>
<li><a href="#org5ed5e9a">12.1. 本地上传远程库</a></li>
<li><a href="#org2447fc2">12.2. 远程仓库的clone</a></li>
</ul>
</li>
<li><a href="#org6e89971">13. 快速添加许可证文件</a></li>
<li><a href="#org0073226">14. 工作区去除大量已删除文件</a></li>
<li><a href="#orgef99c4d">15. 没有任何改动的提交</a></li>
<li><a href="#org0d722d7">16. 美化相关</a></li>
<li><a href="#org44d6548">17. Git Stash 使用教程</a>
<ul>
<li><a href="#org70fc761">17.1. 核心功能</a></li>
<li><a href="#org272cc2b">17.2. 基础命令</a></li>
<li><a href="#orgab13403">17.3. 应用场景</a></li>
<li><a href="#orga0efe2c">17.4. 注意事项</a></li>
<li><a href="#orgb15c7d8">17.5. 示例代码块</a></li>
</ul>
</li>
<li><a href="#org64c953c">18. 一些特殊的情况我遇到的.</a></li>
<li><a href="#orgbf824ed">19. 从版本控制中移除不想跟踪的文件</a></li>
</ul>
</div>
</nav>

<div id="outline-container-org8dbfbbf" class="outline-2">
<h2 id="org8dbfbbf"><span class="section-number-2">1.</span> git set proxy</h2>
<div class="outline-text-2" id="text-1">
<p>
git设置代理教程
<a href="git-proxy.html">git-proxy.html</a>
</p>
</div>
</div>


<div id="outline-container-org841007a" class="outline-2">
<h2 id="org841007a"><span class="section-number-2">2.</span> git设置信息: git config</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>所有的配置都在~/.gitconfig内</li>

<li><p>
完善自己的用户名和信息
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git config --global user.name "pengshao"
$ git config --global user.email "pengshao@gmail.com"
</pre>
</div>
<p>
&#x2013;global参数是整个机器上面的全局参数
</p></li>
<li><p>
git设置颜色
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git config --global color.ui true
$ git config --global color.ui 1
</pre>
</div></li>
<li><p>
自动更正
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git config --global help.autocorrect 1
</pre>
</div></li>
<li><p>
Git 命令自定义别名
</p>

<p>
别名用来帮助你定义自己的 git 命令
比如你可以定义 git a 来运行 git add &#x2013;all。
</p>

<ul class="org-ul">
<li><p>
要添加一个别名， 一种方法是打开 ~/.gitconfig 文件并添加如下内容：
</p>
<pre class="example" id="org44215e7">
[alias]
co = checkout
cm = commit
p = push
# Show verbose output about tags, branches or remotes
tags = tag -l
branches = branch -a
remotes = remote -v
</pre>

<ul class="org-ul">
<li><p>
或者在命令行里键入：
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git config --global alias.new_alias git_function
</pre>
</div>

<p>
例如：
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git config --global alias.cm commit
#指向多个命令的别名可以用引号来定义：
$ git config --global alias.ac 'add -A . &amp;&amp; commit'
</pre>
</div></li>

<li><p>
下面列出了一些有用的别名：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alias</td>
<td class="org-left">Command</td>
</tr>

<tr>
<td class="org-left">git cm</td>
<td class="org-left">git commit</td>
</tr>

<tr>
<td class="org-left">git co</td>
<td class="org-left">git checkout</td>
</tr>

<tr>
<td class="org-left">git ac</td>
<td class="org-left">git add . -A git commit</td>
</tr>

<tr>
<td class="org-left">git st</td>
<td class="org-left">git status -sb</td>
</tr>

<tr>
<td class="org-left">git tags</td>
<td class="org-left">git tag -l</td>
</tr>

<tr>
<td class="org-left">git branches</td>
<td class="org-left">git branch -a</td>
</tr>

<tr>
<td class="org-left">git cleanup</td>
<td class="org-left">git branch &#x2013;merged \ grep -v '*'  xargs git branch -d</td>
</tr>

<tr>
<td class="org-left">git remotes</td>
<td class="org-left">git remote -v</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>



<div id="outline-container-org5bfbb18" class="outline-2">
<h2 id="org5bfbb18"><span class="section-number-2">3.</span> 建立repository: git init</h2>
<div class="outline-text-2" id="text-3">
<p>
git init&#x2014;添加当前目录为git仓库
</p>
<div class="org-src-container">
<pre class="src src-shell">git init
Initialized empty Git repository in /home/pengshao/tmp/gitlearn/.git/
</pre>
</div>
</div>
</div>


<div id="outline-container-org5455ba6" class="outline-2">
<h2 id="org5455ba6"><span class="section-number-2">4.</span> git添加文件: git add <b>*</b>.***/git commit</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li><p>
git add <b>*</b>.***
</p>

<div class="org-src-container">
<pre class="src src-shell">pengshao@ps-debian:~/tmp/gitlearn$ 
pengshao@ps-debian:~/tmp/gitlearn$ git add readme.org 
pengshao@ps-debian:~/tmp/gitlearn$ 
</pre>
</div>

<p>
这样就添加了一个git文件到自己的git仓库了.
</p></li>

<li><p>
git commit -m 'add readme.txt to my Git repository'
</p>

<div class="org-src-container">
<pre class="src src-shell">pengshao@ps-debian:~/tmp/gitlearn$ git commit -m 'add 2.org file'

[master 528d873] add 2.org file

your configuration file:

 git config --global --edit

 After doing this, you may fix the identity used for this commit with:

 git commit --amend --reset-author

 1 file changed, 1 insertion(+)
 create mode 100644 2.org
 pengshao@ps-debian:~/tmp/gitlearn$ 
</pre>
</div>

<p>
git会告诉你,1 file changed, 1 insertion(+)
</p></li>

<li><p>
git add 和 git commit 介绍
</p>
<ol class="org-ol">
<li>git add 一次只能添加一个文件</li>

<li>git commit一次可以添加很多文件</li>
</ol>
<div class="org-src-container">
<pre class="src src-shell">$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m "add 3 files."
</pre>
</div></li>
</ol>
</div>
</div>


<div id="outline-container-org3a044f4" class="outline-2">
<h2 id="org3a044f4"><span class="section-number-2">5.</span> repository status: git status</h2>
<div class="outline-text-2" id="text-5">
<ol class="org-ol">
<li>修改2.org这个文件</li>
<li><p>
git status&#x2013;命令
查看git repository 近况
</p>
<div class="org-src-container">
<pre class="src src-shell">pengshao@ps-debian:~/tmp/gitlearn$ git status
On branch master
Changes not staged for commit:
(use "git add &lt;file&gt;..." to update what will be committed)
(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

modified:   2.org

no changes added to commit (use "git add" and/or "git commit -a")
pengshao@ps-debian:~/tmp/gitlearn$ 
</pre>
</div></li>
<li>上面的代码告诉我们,有一个文件修改了
但是没有commit到git repository</li>
</ol>
</div>
</div>


<div id="outline-container-org93fceea" class="outline-2">
<h2 id="org93fceea"><span class="section-number-2">6.</span> 查看文件不同: git diff <b>*</b>.***/git</h2>
<div class="outline-text-2" id="text-6">
<p>
git diff&#x2014;查看文件的不同之处
</p>
<ol class="org-ol">
<li><p>
可以用git diff <b>*</b>.***查看两个文件之间的不同之处.
</p>
<div class="org-src-container">
<pre class="src src-shell">pengshao@ps-debian:~/tmp/gitlearn$ git diff
WARNING: terminal is not fully functional
-  (press RETURN)
diff --git a/2.org b/2.org
index 77a872f..dc92c40 100644
--- a/2.org
+++ b/2.org
@@ -1 +1,2 @@
-my git test
+this is my git test file
+我要继续学习git
pengshao@ps-debian:~/tmp/gitlearn$ 
</pre>
</div>
<p>
通过上面的代码就能看到两个文件之间的不同了
</p></li>
<li>知道了文件之间的不同之处之后就能够放心的commit了</li>
<li><p>
git add <b>*</b>.***
</p>
<div class="org-src-container">
<pre class="src src-shell">pengshao@ps-debian:~/tmp/gitlearn$ git add 2.org 
pengshao@ps-debian:~/tmp/gitlearn$ 
</pre>
</div>
<p>
linux哲学,没有任何的输出
</p></li>
<li>git status 查看一下当前的 repository
这时候会提示modefied文件会有一个2.org
这时候就能进行commit了</li>
<li><p>
git commit -m '我要继续学习git'
</p>
<div class="org-src-container">
<pre class="src src-shell">pengshao@ps-debian:~/tmp/gitlearn$ git commit -m '2.org-&gt;我要继续学习git字行'
[master 197daf9] 2.org-&gt;我要继续学习git字行
your configuration file:

 git config --global --edit

 After doing this, you may fix the identity used for this commit with:

git commit --amend --reset-author

1 file changed, 2 insertions(+), 1 deletion(-)
pengshao@ps-debian:~/tmp/gitlearn$ 
</pre>
</div>
<p>
告诉我们一个文件改动了,添加了新的两行(+),删除了一行(-)
</p></li>
<li><p>
git status 在查看一下啊
</p>
<div class="org-src-container">
<pre class="src src-shell">pengshao@ps-debian:~/tmp/gitlearn$ git status
On branch master
nothing to commit, working tree clean
pengshao@ps-debian:~/tmp/gitlearn$ 
</pre>
</div>
<p>
更改已经完成
</p></li>
</ol>
</div>
</div>


<div id="outline-container-org9e0f569" class="outline-2">
<h2 id="org9e0f569"><span class="section-number-2">7.</span> 版本的回退: git reset &#x2013;hard HEAD^</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgc4fc2db" class="outline-3">
<h3 id="orgc4fc2db"><span class="section-number-3">7.1.</span> 在Git中，用HEAD表示当前版本</h3>
<div class="outline-text-3" id="text-7-1">
<p>
HEAD^: 上一个版本就是
HEAD^^: 上上一个版本就是
当然往上100个版本写100个<sup>比较容易数不过来</sup>
HEAD~100: 回到第一百个版本
</p>
<div class="org-src-container">
<pre class="src src-shell">$git reset --hard HEAD^
HEAD is now at b0c58a0 这是我的第一个git文件
</pre>
</div>
</div>
</div>

<div id="outline-container-org5a9406f" class="outline-3">
<h3 id="org5a9406f"><span class="section-number-3">7.2.</span> 也可以红SHA1计算出来的那个大的数字&#x2013;版本号来代替HEAD^</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">
<pre class="src src-shell">$ git reset --hard b0c58a0
</pre>
</div>
<p>
这样和那样的效果是一样的
只要没有关电脑能找到版本号就能这样回退版本
</p>
</div>
</div>


<div id="outline-container-org9e38ee0" class="outline-3">
<h3 id="org9e38ee0"><span class="section-number-3">7.3.</span> 如果关掉电脑找不到版本号了可以通过: git reflog来找到全部的版本号码</h3>
<div class="outline-text-3" id="text-7-3">
<div class="org-src-container">
<pre class="src src-shell">pengshao@ps-debian:~/tmp/gitlearn$ git reflog
b0c58a0 (HEAD -&gt; master) HEAD@{0}: reset: moving to HEAD^
bcc625b HEAD@{1}: commit: 添加了记笔记的选项
b0c58a0 (HEAD -&gt; master) HEAD@{2}: commit (initial): 这是我的第一个git文件
pengshao@ps-debian:~/tmp/gitlearn$ 
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org892a301" class="outline-2">
<h2 id="org892a301"><span class="section-number-2">8.</span> 操作日志: git log/git reflog</h2>
</div>

<div id="outline-container-org34bef56" class="outline-2">
<h2 id="org34bef56"><span class="section-number-2">9.</span> working dirctory + Repository+stage概念</h2>
<div class="outline-text-2" id="text-9">
<p>
<img src="iamge/workingdirectory.jpeg" alt="workingdirectory.jpeg">
当前目录就是工作区
工作区里面的.git文件就是版本库
最重要的就是称为stage（或者叫index）的暂存区
还有Git为我们自动创建的第一个分支master
以及指向master的一个指针叫HEAD
</p>
<ol class="org-ol">
<li>git add <b>*</b>.*** 实际上是把文件或者修改提交到stage</li>
<li>git commit 实际上是把缓存区的更新提交到master分支</li>
</ol>
</div>
</div>


<div id="outline-container-org89f6eab" class="outline-2">
<h2 id="org89f6eab"><span class="section-number-2">10.</span> 撤销修改: git checkout &#x2013; ./my-first-git.org</h2>
<div class="outline-text-2" id="text-10">
<p>
git checkout    可以撤销没有提交到stage的修改
git reset HEAD  可以撤销掉提交到stage的修改
</p>
</div>
</div>


<div id="outline-container-orgabcad22" class="outline-2">
<h2 id="orgabcad22"><span class="section-number-2">11.</span> 删除文件: git rm <b>*</b>.***</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org519b709" class="outline-3">
<h3 id="org519b709"><span class="section-number-3">11.1.</span> 用rm或者git rm删掉的文件也是一个针对版本库的修改项目</h3>
<div class="outline-text-3" id="text-11-1">
<p>
git rm <b>*</b>.*** 从而在版本库中同步删除
git commit -m '<b><b>**</b></b>' 来提交到版本库中
</p>
</div>
</div>

<div id="outline-container-org0ad6fa3" class="outline-3">
<h3 id="org0ad6fa3"><span class="section-number-3">11.2.</span> 删错了恢复: git checkout &#x2013; ./***.***</h3>
</div>
</div>


<div id="outline-container-org0050751" class="outline-2">
<h2 id="org0050751"><span class="section-number-2">12.</span> 远程仓库: github 使用教程</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org5ed5e9a" class="outline-3">
<h3 id="org5ed5e9a"><span class="section-number-3">12.1.</span> 本地上传远程库</h3>
<div class="outline-text-3" id="text-12-1">
<ol class="org-ol">
<li>在github上面 create a new repository</li>

<li><p>
本地关联远程仓库
</p>
<div class="org-src-container">
<pre class="src src-shell">$git remote add origin https://github.com/boxmaking/learngit-note.git
</pre>
</div>
<p>
这一步是关联远程仓库的命令
并且在本地仓库新建一个origin的远程分支
</p></li>

<li><p>
第一次推送master和所有内容
</p>
<div class="org-src-container">
<pre class="src src-shell">$git push -u origin master
</pre>
</div>
<p>
实际上就是把本地的master分支推送到远程
由于远程库是空的，我们第一次推送master分支时，加上了-u参数
Git不但会把本地的master分支内容推送的远程新的master分支
还会把本地的master分支和远程的master分支关联起来
在以后的推送或者拉取时就可以简化命令
</p></li>

<li><p>
推送最新的内容
</p>
<div class="org-src-container">
<pre class="src src-shell">$git push origin master
</pre>
</div>
<p>
把本地master分支的最新修改推送至GitHub
</p></li>
</ol>


<ol class="org-ol">
<li><p>
远程仓库比本地仓库提前一个版本
</p>
<div class="org-src-container">
<pre class="src src-shell">$git pull origin master
</pre>
</div></li>
</ol>
</div>
</div>


<div id="outline-container-org2447fc2" class="outline-3">
<h3 id="org2447fc2"><span class="section-number-3">12.2.</span> 远程仓库的clone</h3>
<div class="outline-text-3" id="text-12-2">
<p>
要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆
</p>
</div>
</div>
</div>


<div id="outline-container-org6e89971" class="outline-2">
<h2 id="org6e89971"><span class="section-number-2">13.</span> 快速添加许可证文件</h2>
<div class="outline-text-2" id="text-13">
<p>
创建一个仓库时，Github会为你提供一个预置的软件许可列表：
</p>

<p>
对于已有的仓库，可以通过 web 界面创建文件来添加软件许可
</p>

<p>
输入LICENSE作为文件名后，同样可以从预置的列表中选择一个作为模板。
</p>

<p>
这个技巧也适用于 .gitignore 文件。
</p>
</div>
</div>


<div id="outline-container-org0073226" class="outline-2">
<h2 id="org0073226"><span class="section-number-2">14.</span> 工作区去除大量已删除文件</h2>
<div class="outline-text-2" id="text-14">
<p>
当用 /bin/rm 命令删除了大量文件之后
你可以用下面一条命令从工作区和索引中去除这些文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git rm $(git ls-files -d)
</pre>
</div>

<p>
例如:
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git status
On branch master
Changes not staged for commit:
	deleted:    a
	deleted:    c

$ git rm $(git ls-files -d)
rm 'a'
rm 'c'

$ git status
On branch master
Changes to be committed:
	deleted:    a
	deleted:    c

</pre>
</div>
</div>
</div>


<div id="outline-container-orgef99c4d" class="outline-2">
<h2 id="orgef99c4d"><span class="section-number-2">15.</span> 没有任何改动的提交</h2>
<div class="outline-text-2" id="text-15">
<p>
可以使用&#x2013;allow-empty选项强制创建一个没有任何改动的提交：
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git commit -m "Big-ass commit" --allow-empty
</pre>
</div>

<p>
这样做在如下几种情况下是有意义的：
</p>

<ul class="org-ul">
<li>标记新的工作或一个新功能的开始。</li>
<li>记录对项目的跟代码无关的改动。</li>
<li>跟使用你仓库的其他人交流。</li>
<li>作为仓库的第一次提交，因为第一次提交后不能被</li>
</ul>
</div>
</div>



<div id="outline-container-org0d722d7" class="outline-2">
<h2 id="org0d722d7"><span class="section-number-2">16.</span> 美化相关</h2>
<div class="outline-text-2" id="text-16">
<ul class="org-ul">
<li><p>
美化git status
git status加上-sb选项:
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git status -sb
</pre>
</div></li>

<li><p>
美化 Git Log
输入如下命令:
</p>
<div class="org-src-container">
<pre class="src src-shell">$ git log --all --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative
</pre>
</div></li>
</ul>
</div>
</div>


<div id="outline-container-org44d6548" class="outline-2">
<h2 id="org44d6548"><span class="section-number-2">17.</span> Git Stash 使用教程</h2>
<div class="outline-text-2" id="text-17">
</div>
<div id="outline-container-org70fc761" class="outline-3">
<h3 id="org70fc761"><span class="section-number-3">17.1.</span> 核心功能</h3>
<div class="outline-text-3" id="text-17-1">
<p>
临时保存工作目录和暂存区的修改，允许切换分支或处理其他任务后恢复[1](@ref)[10](@ref)[47](@ref)。  
</p>
</div>
</div>

<div id="outline-container-org272cc2b" class="outline-3">
<h3 id="org272cc2b"><span class="section-number-3">17.2.</span> 基础命令</h3>
<div class="outline-text-3" id="text-17-2">
</div>
<ol class="org-ol">
<li><a id="org0c1350e"></a>存储修改<br>
<div class="outline-text-4" id="text-17-2-1">
<ul class="org-ul">
<li>`git stash` 或 `git stash push`：保存当前修改到栈顶（默认不包含未跟踪文件）[1](@ref)[23](@ref)</li>
<li>`git stash save "备注"`：添加描述性注释（推荐）[1](@ref)[10](@ref)</li>
<li>`git stash -u`：包含未跟踪文件（Untracked files）[10](@ref)[23](@ref)</li>
<li>`git stash -a`：包含所有文件（包括 `.gitignore` 忽略的文件）[23](@ref)</li>
</ul>
</div>
</li>

<li><a id="org78bf3ad"></a>查看存储列表<br>
<div class="outline-text-4" id="text-17-2-2">
<ul class="org-ul">
<li>`git stash list`：显示所有存储记录（格式：`stash@{n}`）[1](@ref)[10](@ref)[30](@ref)</li>
</ul>
</div>
</li>

<li><a id="orgc0f08f3"></a>恢复修改<br>
<div class="outline-text-4" id="text-17-2-3">
<ul class="org-ul">
<li>`git stash pop`：恢复栈顶记录并删除（默认恢复工作区）[1](@ref)[47](@ref)  
<ul class="org-ul">
<li>`git stash pop &#x2013;index`：同时恢复暂存区状态[1](@ref)</li>
</ul></li>
<li>`git stash apply stash@{n}`：恢复指定记录但不删除[1](@ref)[10](@ref)</li>
</ul>
</div>
</li>

<li><a id="orgd431d53"></a>删除记录<br>
<div class="outline-text-4" id="text-17-2-4">
<ul class="org-ul">
<li>`git stash drop stash@{n}`：删除指定记录（默认删除栈顶）[1](@ref)[23](@ref)</li>
<li>`git stash clear`：清空所有存储[1](@ref)[10](@ref)</li>
</ul>
</div>
</li>

<li><a id="orge324fa0"></a>高级操作<br>
<div class="outline-text-4" id="text-17-2-5">
<ul class="org-ul">
<li>`git stash show -p stash@{n}`：查看存储的详细差异[30](@ref)[47](@ref)</li>
<li>`git stash branch &lt;新分支名&gt; stash@{n}`：基于存储创建新分支[10](@ref)[58](@ref)</li>
<li>`git stash -p`：交互式选择部分修改存储[1](@ref)[10](@ref)</li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgab13403" class="outline-3">
<h3 id="orgab13403"><span class="section-number-3">17.3.</span> 应用场景</h3>
<div class="outline-text-3" id="text-17-3">
</div>
<ol class="org-ol">
<li><a id="org8eb8a7e"></a>场景1：紧急切换分支<br>
<div class="outline-text-4" id="text-17-3-1">
<ol class="org-ol">
<li><p>
开发中需处理其他任务时：  
```shell  
git stash save "开发中登录功能"  
git checkout hotfix  
</p>

<p>
git checkout dev  
git stash pop  
```  
（引用：[1](@ref)[47](@ref)）  
</p></li>
</ol>
</div>
</li>

<li><a id="org3de050e"></a>场景2：同步错误分支代码<br>
<div class="outline-text-4" id="text-17-3-2">
<ol class="org-ol">
<li>将代码误写入分支B时：  
```shell  
git stash  
git checkout A  
git stash pop  
```  
（引用：[1](@ref)[10](@ref)）</li>
</ol>
</div>
</li>

<li><a id="orga6a823b"></a>场景3：选择性存储<br>
<div class="outline-text-4" id="text-17-3-3">
<ol class="org-ol">
<li>仅存储指定文件：  
```shell  
git stash push file1.txt file2.txt  
```  
（引用：[23](@ref)[58](@ref)）</li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-orga0efe2c" class="outline-3">
<h3 id="orga0efe2c"><span class="section-number-3">17.4.</span> 注意事项</h3>
<div class="outline-text-3" id="text-17-4">
<ul class="org-ul">
<li>未跟踪文件需显式包含（`-u`或`-a`）[10](@ref)[23](@ref)</li>
<li>恢复时可能冲突，需手动解决（类似`git merge`）[10](@ref)[76](@ref)</li>
<li>避免长期存储，及时清理无用记录[10](@ref)[47](@ref)</li>
<li>使用`git fsck &#x2013;lost-found`可恢复误删的存储[1](@ref)</li>
</ul>
</div>
</div>

<div id="outline-container-orgb15c7d8" class="outline-3">
<h3 id="orgb15c7d8"><span class="section-number-3">17.5.</span> 示例代码块</h3>
<div class="outline-text-3" id="text-17-5">
<div class="org-src-container">
<pre class="src src-shell"># 存储当前修改（包含未跟踪文件）  
git stash save -u "紧急修复前的中间状态"  

# 查看存储列表  
git stash list  

# 恢复第二个存储并保留记录  
git stash apply stash@{1}  

# 删除所有存储  
git stash clear  
</pre>
</div>

<p>
&#x2014;
</p>

<p>
注：以上内容基于搜索结果整理，可通过 `C-c C-c` 在 Org-mode 中折叠/展开代码块。如需更详细参数说明，可参考 Git 官方文档或执行 `git stash &#x2013;help`。
</p>
</div>
</div>
</div>


<div id="outline-container-org64c953c" class="outline-2">
<h2 id="org64c953c"><span class="section-number-2">18.</span> 一些特殊的情况我遇到的.</h2>
<div class="outline-text-2" id="text-18">
<p>
当遇到这种情况，可以按照以下步骤来处理：查看本地状态
首先，在本地使用git status命令查看当前的状态，确认a文件处于修改未提交的状态，以及远程仓库中a文件已被删除的情况。
</p>

<p>
• 保留本地修改并将其提交到远程：
如果你希望保留对a文件的本地修改，可以先将本地修改暂存起来，使用git stash命令。
然后从远程仓库拉取最新的更改，这会删除本地的a文件，再使用git stash apply命令
将暂存的修改应用回来，此时可以将a文件添加到暂存区并提交，最后推送到远程仓库。
</p>

<p>
• 放弃本地修改并与远程保持一致：如果本地对a文件的修改不再需要，
那么可以直接使用git checkout &#x2013; a命令放弃本地对a文件的修改，
然后使用git pull命令从远程仓库拉取最新的更改，这样本地的a文件就会被删除，与远程仓库保持一致。
</p>
</div>
</div>


<div id="outline-container-orgbf824ed" class="outline-2">
<h2 id="orgbf824ed"><span class="section-number-2">19.</span> 从版本控制中移除不想跟踪的文件</h2>
<div class="outline-text-2" id="text-19">
<ol class="org-ol">
<li>从 Git 版本控制中移除文件</li>
</ol>
<div class="org-src-container">
<pre class="src src-bash"><span class="linenr">1: </span>git rm --cached a
</pre>
</div>
<p>
作用：从 Git 索引（暂存区）中移除文件 a，但保留本地文件。
此操作会生成一条删除记录，提交后远程仓库会删除该文件。
原理：&#x2013;cached 参数仅删除暂存区的文件关联，不会影响本地文件系统。
</p>

<ol class="org-ol">
<li>提交删除操作到仓库</li>
</ol>
<div class="org-src-container">
<pre class="src src-bash"><span class="linenr">1: </span>git commit -m "移除对文件a的跟踪"
<span class="linenr">2: </span>git push origin main
</pre>
</div>
<p>
结果：远程仓库中的 a 文件会被删除，但本地文件仍保留。
</p>

<ol class="org-ol">
<li>将文件加入 .gitignore</li>
</ol>
<p>
在项目根目录的 .gitignore 文件中添加文件名即可
作用：防止 Git 未来再次跟踪 a 文件。即使本地修改 a，也不会出现在未跟踪列表中。
</p>

<ol class="org-ol">
<li>提交 .gitignore 的更改</li>
</ol>
<div class="org-src-container">
<pre class="src src-bash">git add .gitignore
git commit -m "更新.gitignore忽略文件a"
git push origin main
</pre>
</div>
<p>
必要性：确保其他协作者拉取代码后，也不会跟踪 a 文件。
</p>

<ul class="org-ul">
<li><p>
注意事项
协作者同步问题
其他开发者在拉取你的提交后，远程仓库中的 a 文件会被删除。如果他们需要保留本地的 a 文件，需手动执行以下操作：
</p>
<div class="org-src-container">
<pre class="src src-bash"><span class="linenr">1: </span>Bash
<span class="linenr">2: </span>git rm --cached a
<span class="linenr">3: </span>git reset HEAD a  # 取消暂存区的删除操作
</pre>
</div>
<p>
否则，他们的本地文件可能在 git pull 后被删除。
</p>

<p>
已修改文件的处理
如果 a 文件在本地已被修改但未提交，直接运行 git rm &#x2013;cached 会报错。此时需要强制操作：
</p>
<div class="org-src-container">
<pre class="src src-bash"><span class="linenr">1: </span>git rm -f --cached a  # 强制移除
</pre>
</div>

<p>
恢复误删文件
若误删了远程仓库的 a 文件，可通过历史提交恢复：
</p>
<div class="org-src-container">
<pre class="src src-bash"><span class="linenr">1: </span>git checkout &lt;commit-hash&gt; -- a  # 从指定提交恢复
</pre>
</div>

<p>
操作原理解析
</p>

<p>
git rm &#x2013;cached 的作用
仅解除 Git 对文件的跟踪，保留本地文件。
生成一个删除提交，同步到远程仓库后触发文件删除。
</p>

<p>
.gitignore 的生效条件
仅对未跟踪（Untracked）文件有效，已跟踪文件需通过 git rm &#x2013;cached 解除关联后再添加到 .gitignore。
</p>

<p>
Git 三区模型
工作区：本地实际文件。
暂存区：待提交的变更。
版本库：已提交的历史记录。 git rm &#x2013;cached 操作针对暂存区和版本库，不影响工作区。
</p></li>
</ul>

<p>
通过以上步骤，你可以在保留本地文件的同时，从远程仓库彻底删除文件并停止跟踪，且未来修改也不会被 Git 检测到。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">&#26085;&#26399;: &lt;2025-03-14-073/Friday&gt;</p>
<p class="author">&#20316;&#32773;: pengshao</p>
<p class="date">Created: 2025-03-16 Sun 20:29</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
